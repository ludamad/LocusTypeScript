=== tests/cases/conformance/types/typeRelationships/typeInference/contextualSignatureInstantiation.ts ===
// TypeScript Spec, section 4.12.2:
// If e is an expression of a function type that contains exactly one generic call signature and no other members,
// and T is a function type with exactly one non - generic call signature and no other members, then any inferences
// made for type parameters referenced by the parameters of T's call signature are fixed, and e's type is changed
// to a function type with e's call signature instantiated in the context of Tï¿½s call signature (section 3.8.5).

declare function foo<T>(cb: (x: number, y: string) => T): T;
>foo : <T>(cb: (x: number, y: string) => T) => T
>T : T
>cb : (x: number, y: string) => T
>x : number
>y : string
>T : T
>T : T

declare function bar<T, U, V>(x: T, y: U, cb: (x: T, y: U) => V): V;
>bar : <T, U, V>(x: T, y: U, cb: (x: T, y: U) => V) => V
>T : T
>U : U
>V : V
>x : T
>T : T
>y : U
>U : U
>cb : (x: T, y: U) => V
>x : T
>T : T
>y : U
>U : U
>V : V
>V : V

declare function f(x: number, y: string): boolean;
>f : (x: number, y: string) => boolean
>x : number
>y : string

declare function g<T>(x: T, y: T): T;
>g : <T>(x: T, y: T) => T
>T : T
>x : T
>T : T
>y : T
>T : T
>T : T

var a: boolean;
>a : boolean

var a = foo(f);  // Should be boolean
>a : boolean
>foo(f) : boolean
>foo : <T>(cb: (x: number, y: string) => T) => T
>f : (x: number, y: string) => boolean

var b: number | string;
>b : string | number

var b = foo(g);            // Should be number | string
>b : string | number
>foo(g) : string | number
>foo : <T>(cb: (x: number, y: string) => T) => T
>g : <T>(x: T, y: T) => T

var b = bar(1, "one", g);  // Should be number | string
>b : string | number
>bar(1, "one", g) : string | number
>bar : <T, U, V>(x: T, y: U, cb: (x: T, y: U) => V) => V
>g : <T>(x: T, y: T) => T

var b = bar("one", 1, g);  // Should be number | string
>b : string | number
>bar("one", 1, g) : string | number
>bar : <T, U, V>(x: T, y: U, cb: (x: T, y: U) => V) => V
>g : <T>(x: T, y: T) => T

var c: number;
>c : number

var c = bar(1, 1, g);      // Should be number
>c : number
>bar(1, 1, g) : number
>bar : <T, U, V>(x: T, y: U, cb: (x: T, y: U) => V) => V
>g : <T>(x: T, y: T) => T

