=== tests/cases/compiler/inferentialTypingWithFunctionTypeZip.ts ===
var pair: <T, S>(x: T) => (y: S) => { x: T; y: S; }
>pair : <T, S>(x: T) => (y: S) => { x: T; y: S; }, Symbol(pair,Decl(inferentialTypingWithFunctionTypeZip.ts,0,3))
>T : T, Symbol(T,Decl(inferentialTypingWithFunctionTypeZip.ts,0,11))
>S : S, Symbol(S,Decl(inferentialTypingWithFunctionTypeZip.ts,0,13))
>x : T, Symbol(x,Decl(inferentialTypingWithFunctionTypeZip.ts,0,17))
>T : T, Symbol(T,Decl(inferentialTypingWithFunctionTypeZip.ts,0,11))
>y : S, Symbol(y,Decl(inferentialTypingWithFunctionTypeZip.ts,0,27))
>S : S, Symbol(S,Decl(inferentialTypingWithFunctionTypeZip.ts,0,13))
>x : T, Symbol(x,Decl(inferentialTypingWithFunctionTypeZip.ts,0,37))
>T : T, Symbol(T,Decl(inferentialTypingWithFunctionTypeZip.ts,0,11))
>y : S, Symbol(y,Decl(inferentialTypingWithFunctionTypeZip.ts,0,43))
>S : S, Symbol(S,Decl(inferentialTypingWithFunctionTypeZip.ts,0,13))

var zipWith: <T, S, U>(a: T[], b: S[], f: (x: T) => (y: S) => U) => U[];
>zipWith : <T, S, U>(a: T[], b: S[], f: (x: T) => (y: S) => U) => U[], Symbol(zipWith,Decl(inferentialTypingWithFunctionTypeZip.ts,1,3))
>T : T, Symbol(T,Decl(inferentialTypingWithFunctionTypeZip.ts,1,14))
>S : S, Symbol(S,Decl(inferentialTypingWithFunctionTypeZip.ts,1,16))
>U : U, Symbol(U,Decl(inferentialTypingWithFunctionTypeZip.ts,1,19))
>a : T[], Symbol(a,Decl(inferentialTypingWithFunctionTypeZip.ts,1,23))
>T : T, Symbol(T,Decl(inferentialTypingWithFunctionTypeZip.ts,1,14))
>b : S[], Symbol(b,Decl(inferentialTypingWithFunctionTypeZip.ts,1,30))
>S : S, Symbol(S,Decl(inferentialTypingWithFunctionTypeZip.ts,1,16))
>f : (x: T) => (y: S) => U, Symbol(f,Decl(inferentialTypingWithFunctionTypeZip.ts,1,38))
>x : T, Symbol(x,Decl(inferentialTypingWithFunctionTypeZip.ts,1,43))
>T : T, Symbol(T,Decl(inferentialTypingWithFunctionTypeZip.ts,1,14))
>y : S, Symbol(y,Decl(inferentialTypingWithFunctionTypeZip.ts,1,53))
>S : S, Symbol(S,Decl(inferentialTypingWithFunctionTypeZip.ts,1,16))
>U : U, Symbol(U,Decl(inferentialTypingWithFunctionTypeZip.ts,1,19))
>U : U, Symbol(U,Decl(inferentialTypingWithFunctionTypeZip.ts,1,19))

var result = zipWith([1, 2], ['a', 'b'], pair);
>result : { x: number; y: {}; }[], Symbol(result,Decl(inferentialTypingWithFunctionTypeZip.ts,2,3))
>zipWith([1, 2], ['a', 'b'], pair) : { x: number; y: {}; }[]
>zipWith : <T, S, U>(a: T[], b: S[], f: (x: T) => (y: S) => U) => U[], Symbol(zipWith,Decl(inferentialTypingWithFunctionTypeZip.ts,1,3))
>[1, 2] : number[]
>1 : number
>2 : number
>['a', 'b'] : string[]
>'a' : string
>'b' : string
>pair : <T, S>(x: T) => (y: S) => { x: T; y: S; }, Symbol(pair,Decl(inferentialTypingWithFunctionTypeZip.ts,0,3))

var i = result[0].x; // number
>i : number, Symbol(i,Decl(inferentialTypingWithFunctionTypeZip.ts,3,3))
>result[0].x : number, Symbol(x,Decl(inferentialTypingWithFunctionTypeZip.ts,0,37))
>result[0] : { x: number; y: {}; }
>result : { x: number; y: {}; }[], Symbol(result,Decl(inferentialTypingWithFunctionTypeZip.ts,2,3))
>0 : number
>x : number, Symbol(x,Decl(inferentialTypingWithFunctionTypeZip.ts,0,37))

