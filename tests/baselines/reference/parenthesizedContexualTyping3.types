=== tests/cases/conformance/expressions/contextualTyping/parenthesizedContexualTyping3.ts ===

// Contextual typing for parenthesized substitution expressions in tagged templates.

/**
 * tempFun - Can't have fun for too long.
 */
function tempFun<T>(tempStrs: TemplateStringsArray, g: (x: T) => T, x: T): T;
>tempFun : { <T>(tempStrs: TemplateStringsArray, g: (x: T) => T, x: T): T; <T>(tempStrs: TemplateStringsArray, g: (x: T) => T, h: (y: T) => T, x: T): T; }
>T : T
>tempStrs : TemplateStringsArray
>TemplateStringsArray : TemplateStringsArray
>g : (x: T) => T
>x : T
>T : T
>T : T
>x : T
>T : T
>T : T

function tempFun<T>(tempStrs: TemplateStringsArray, g: (x: T) => T, h: (y: T) => T, x: T): T;
>tempFun : { <T>(tempStrs: TemplateStringsArray, g: (x: T) => T, x: T): T; <T>(tempStrs: TemplateStringsArray, g: (x: T) => T, h: (y: T) => T, x: T): T; }
>T : T
>tempStrs : TemplateStringsArray
>TemplateStringsArray : TemplateStringsArray
>g : (x: T) => T
>x : T
>T : T
>T : T
>h : (y: T) => T
>y : T
>T : T
>T : T
>x : T
>T : T
>T : T

function tempFun<T>(tempStrs: TemplateStringsArray, g: (x: T) => T, x: T): T {
>tempFun : { <T>(tempStrs: TemplateStringsArray, g: (x: T) => T, x: T): T; <T>(tempStrs: TemplateStringsArray, g: (x: T) => T, h: (y: T) => T, x: T): T; }
>T : T
>tempStrs : TemplateStringsArray
>TemplateStringsArray : TemplateStringsArray
>g : (x: T) => T
>x : T
>T : T
>T : T
>x : T
>T : T
>T : T

    return g(x);
>g(x) : T
>g : (x: T) => T
>x : T
}

var a = tempFun `${ x => x }  ${ 10 }`
>a : number
>tempFun : { <T>(tempStrs: TemplateStringsArray, g: (x: T) => T, x: T): T; <T>(tempStrs: TemplateStringsArray, g: (x: T) => T, h: (y: T) => T, x: T): T; }
>x => x : (x: number) => number
>x : number
>x : number

var b = tempFun `${ (x => x) }  ${ 10 }`
>b : any
>tempFun : { <T>(tempStrs: TemplateStringsArray, g: (x: T) => T, x: T): T; <T>(tempStrs: TemplateStringsArray, g: (x: T) => T, h: (y: T) => T, x: T): T; }
>(x => x) : (x: any) => any
>x => x : (x: any) => any
>x : any
>x : any

var c = tempFun `${ ((x => x)) } ${ 10 }`
>c : any
>tempFun : { <T>(tempStrs: TemplateStringsArray, g: (x: T) => T, x: T): T; <T>(tempStrs: TemplateStringsArray, g: (x: T) => T, h: (y: T) => T, x: T): T; }
>((x => x)) : (x: any) => any
>(x => x) : (x: any) => any
>x => x : (x: any) => any
>x : any
>x : any

var d = tempFun `${ x => x } ${ x => x } ${ 10 }`
>d : number
>tempFun : { <T>(tempStrs: TemplateStringsArray, g: (x: T) => T, x: T): T; <T>(tempStrs: TemplateStringsArray, g: (x: T) => T, h: (y: T) => T, x: T): T; }
>x => x : (x: number) => number
>x : number
>x : number
>x => x : (x: number) => number
>x : number
>x : number

var e = tempFun `${ x => x } ${ (x => x) } ${ 10 }`
>e : any
>tempFun : { <T>(tempStrs: TemplateStringsArray, g: (x: T) => T, x: T): T; <T>(tempStrs: TemplateStringsArray, g: (x: T) => T, h: (y: T) => T, x: T): T; }
>x => x : (x: any) => any
>x : any
>x : any
>(x => x) : (x: any) => any
>x => x : (x: any) => any
>x : any
>x : any

var f = tempFun `${ x => x } ${ ((x => x)) } ${ 10 }`
>f : any
>tempFun : { <T>(tempStrs: TemplateStringsArray, g: (x: T) => T, x: T): T; <T>(tempStrs: TemplateStringsArray, g: (x: T) => T, h: (y: T) => T, x: T): T; }
>x => x : (x: any) => any
>x : any
>x : any
>((x => x)) : (x: any) => any
>(x => x) : (x: any) => any
>x => x : (x: any) => any
>x : any
>x : any

var g = tempFun `${ (x => x) } ${ (((x => x))) } ${ 10 }`
>g : any
>tempFun : { <T>(tempStrs: TemplateStringsArray, g: (x: T) => T, x: T): T; <T>(tempStrs: TemplateStringsArray, g: (x: T) => T, h: (y: T) => T, x: T): T; }
>(x => x) : (x: any) => any
>x => x : (x: any) => any
>x : any
>x : any
>(((x => x))) : (x: any) => any
>((x => x)) : (x: any) => any
>(x => x) : (x: any) => any
>x => x : (x: any) => any
>x : any
>x : any

var h = tempFun `${ (x => x) } ${ (((x => x))) } ${ undefined }`
>h : any
>tempFun : { <T>(tempStrs: TemplateStringsArray, g: (x: T) => T, x: T): T; <T>(tempStrs: TemplateStringsArray, g: (x: T) => T, h: (y: T) => T, x: T): T; }
>(x => x) : (x: any) => any
>x => x : (x: any) => any
>x : any
>x : any
>(((x => x))) : (x: any) => any
>((x => x)) : (x: any) => any
>(x => x) : (x: any) => any
>x => x : (x: any) => any
>x : any
>x : any
>undefined : undefined

