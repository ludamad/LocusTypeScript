=== tests/cases/conformance/expressions/contextualTyping/functionExpressionContextualTyping.ts ===
enum E { red, blue }
>E : E, Symbol(E, Decl(functionExpressionContextualTyping.ts, 0, 0))
>red : E, Symbol(E.red, Decl(functionExpressionContextualTyping.ts, 0, 8))
>blue : E, Symbol(E.blue, Decl(functionExpressionContextualTyping.ts, 0, 13))

var g0: (n: number, s:string) => number;
>g0 : (n: number, s: string) => number, Symbol(g0, Decl(functionExpressionContextualTyping.ts, 2, 3))
>n : number, Symbol(n, Decl(functionExpressionContextualTyping.ts, 2, 9))
>s : string, Symbol(s, Decl(functionExpressionContextualTyping.ts, 2, 19))

var g: ((s: string, w: boolean) => void) | ((n: number) => number);
>g : ((s: string, w: boolean) => void) | ((n: number) => number), Symbol(g, Decl(functionExpressionContextualTyping.ts, 3, 3))
>s : string, Symbol(s, Decl(functionExpressionContextualTyping.ts, 3, 9))
>w : boolean, Symbol(w, Decl(functionExpressionContextualTyping.ts, 3, 19))
>n : number, Symbol(n, Decl(functionExpressionContextualTyping.ts, 3, 45))

var g1: ((s: string, w: boolean) => void) | ((s: string, w: number) => string);
>g1 : ((s: string, w: boolean) => void) | ((s: string, w: number) => string), Symbol(g1, Decl(functionExpressionContextualTyping.ts, 4, 3))
>s : string, Symbol(s, Decl(functionExpressionContextualTyping.ts, 4, 10))
>w : boolean, Symbol(w, Decl(functionExpressionContextualTyping.ts, 4, 20))
>s : string, Symbol(s, Decl(functionExpressionContextualTyping.ts, 4, 46))
>w : number, Symbol(w, Decl(functionExpressionContextualTyping.ts, 4, 56))

g1 = (j, m) => { } // Per spec, no contextual signature can be extracted in this case.
>g1 = (j, m) => { } : (j: any, m: any) => void
>g1 : ((s: string, w: boolean) => void) | ((s: string, w: number) => string), Symbol(g1, Decl(functionExpressionContextualTyping.ts, 4, 3))
>(j, m) => { } : (j: any, m: any) => void
>j : any, Symbol(j, Decl(functionExpressionContextualTyping.ts, 6, 6))
>m : any, Symbol(m, Decl(functionExpressionContextualTyping.ts, 6, 8))

g = (k, h=true) => { k.toLowerCase() };
>g = (k, h=true) => { k.toLowerCase() } : (k: any, h?: boolean) => void
>g : ((s: string, w: boolean) => void) | ((n: number) => number), Symbol(g, Decl(functionExpressionContextualTyping.ts, 3, 3))
>(k, h=true) => { k.toLowerCase() } : (k: any, h?: boolean) => void
>k : any, Symbol(k, Decl(functionExpressionContextualTyping.ts, 7, 5))
>h : boolean, Symbol(h, Decl(functionExpressionContextualTyping.ts, 7, 7))
>true : boolean
>k.toLowerCase() : any
>k.toLowerCase : any
>k : any, Symbol(k, Decl(functionExpressionContextualTyping.ts, 7, 5))
>toLowerCase : any

g = (k) => { k.toLowerCase() };
>g = (k) => { k.toLowerCase() } : (k: any) => void
>g : ((s: string, w: boolean) => void) | ((n: number) => number), Symbol(g, Decl(functionExpressionContextualTyping.ts, 3, 3))
>(k) => { k.toLowerCase() } : (k: any) => void
>k : any, Symbol(k, Decl(functionExpressionContextualTyping.ts, 8, 5))
>k.toLowerCase() : any
>k.toLowerCase : any
>k : any, Symbol(k, Decl(functionExpressionContextualTyping.ts, 8, 5))
>toLowerCase : any

g = (i) => {
>g = (i) => {    i.toExponential();    return i;} : (i: any) => any
>g : ((s: string, w: boolean) => void) | ((n: number) => number), Symbol(g, Decl(functionExpressionContextualTyping.ts, 3, 3))
>(i) => {    i.toExponential();    return i;} : (i: any) => any
>i : any, Symbol(i, Decl(functionExpressionContextualTyping.ts, 9, 5))

    i.toExponential();
>i.toExponential() : any
>i.toExponential : any
>i : any, Symbol(i, Decl(functionExpressionContextualTyping.ts, 9, 5))
>toExponential : any

    return i;
>i : any, Symbol(i, Decl(functionExpressionContextualTyping.ts, 9, 5))

};  // Per spec, no contextual signature can be extracted in this case.

var h: ((s: string, w: boolean) => void) | ((s: string, w: boolean) => string);
>h : ((s: string, w: boolean) => void) | ((s: string, w: boolean) => string), Symbol(h, Decl(functionExpressionContextualTyping.ts, 14, 3))
>s : string, Symbol(s, Decl(functionExpressionContextualTyping.ts, 14, 9))
>w : boolean, Symbol(w, Decl(functionExpressionContextualTyping.ts, 14, 19))
>s : string, Symbol(s, Decl(functionExpressionContextualTyping.ts, 14, 45))
>w : boolean, Symbol(w, Decl(functionExpressionContextualTyping.ts, 14, 55))

h = (k, h) => { };
>h = (k, h) => { } : (k: string, h: boolean) => void
>h : ((s: string, w: boolean) => void) | ((s: string, w: boolean) => string), Symbol(h, Decl(functionExpressionContextualTyping.ts, 14, 3))
>(k, h) => { } : (k: string, h: boolean) => void
>k : string, Symbol(k, Decl(functionExpressionContextualTyping.ts, 15, 5))
>h : boolean, Symbol(h, Decl(functionExpressionContextualTyping.ts, 15, 7))

var i: typeof g0 | ((n: number, s: string) => string);
>i : ((n: number, s: string) => number) | ((n: number, s: string) => string), Symbol(i, Decl(functionExpressionContextualTyping.ts, 17, 3))
>g0 : (n: number, s: string) => number, Symbol(g0, Decl(functionExpressionContextualTyping.ts, 2, 3))
>n : number, Symbol(n, Decl(functionExpressionContextualTyping.ts, 17, 21))
>s : string, Symbol(s, Decl(functionExpressionContextualTyping.ts, 17, 31))

i = (foo, bar) => { return foo + 1; }
>i = (foo, bar) => { return foo + 1; } : (foo: number, bar: string) => number
>i : ((n: number, s: string) => number) | ((n: number, s: string) => string), Symbol(i, Decl(functionExpressionContextualTyping.ts, 17, 3))
>(foo, bar) => { return foo + 1; } : (foo: number, bar: string) => number
>foo : number, Symbol(foo, Decl(functionExpressionContextualTyping.ts, 18, 5))
>bar : string, Symbol(bar, Decl(functionExpressionContextualTyping.ts, 18, 9))
>foo + 1 : number
>foo : number, Symbol(foo, Decl(functionExpressionContextualTyping.ts, 18, 5))
>1 : number

i = (foo, bar) => { return "hello"; }
>i = (foo, bar) => { return "hello"; } : (foo: number, bar: string) => string
>i : ((n: number, s: string) => number) | ((n: number, s: string) => string), Symbol(i, Decl(functionExpressionContextualTyping.ts, 17, 3))
>(foo, bar) => { return "hello"; } : (foo: number, bar: string) => string
>foo : number, Symbol(foo, Decl(functionExpressionContextualTyping.ts, 19, 5))
>bar : string, Symbol(bar, Decl(functionExpressionContextualTyping.ts, 19, 9))
>"hello" : string

var j: (name: string, num: number, boo: boolean) => void;
>j : (name: string, num: number, boo: boolean) => void, Symbol(j, Decl(functionExpressionContextualTyping.ts, 20, 3))
>name : string, Symbol(name, Decl(functionExpressionContextualTyping.ts, 20, 8))
>num : number, Symbol(num, Decl(functionExpressionContextualTyping.ts, 20, 21))
>boo : boolean, Symbol(boo, Decl(functionExpressionContextualTyping.ts, 20, 34))

j = (name, number) => { };
>j = (name, number) => { } : (name: string, number: number) => void
>j : (name: string, num: number, boo: boolean) => void, Symbol(j, Decl(functionExpressionContextualTyping.ts, 20, 3))
>(name, number) => { } : (name: string, number: number) => void
>name : string, Symbol(name, Decl(functionExpressionContextualTyping.ts, 21, 5))
>number : number, Symbol(number, Decl(functionExpressionContextualTyping.ts, 21, 10))

var k: (n: E) => string = (number = 1) => { return "hello"; };
>k : (n: E) => string, Symbol(k, Decl(functionExpressionContextualTyping.ts, 23, 3))
>n : E, Symbol(n, Decl(functionExpressionContextualTyping.ts, 23, 8))
>E : E, Symbol(E, Decl(functionExpressionContextualTyping.ts, 0, 0))
>(number = 1) => { return "hello"; } : (number?: E) => string
>number : E, Symbol(number, Decl(functionExpressionContextualTyping.ts, 23, 27))
>1 : number
>"hello" : string

var k1: (n: {}) => string = (number = 1) => { return "hello"; };
>k1 : (n: {}) => string, Symbol(k1, Decl(functionExpressionContextualTyping.ts, 24, 3))
>n : {}, Symbol(n, Decl(functionExpressionContextualTyping.ts, 24, 9))
>(number = 1) => { return "hello"; } : (number?: {}) => string
>number : {}, Symbol(number, Decl(functionExpressionContextualTyping.ts, 24, 29))
>1 : number
>"hello" : string

class C<T, U> {
>C : C<T, U>, Symbol(C, Decl(functionExpressionContextualTyping.ts, 24, 64))
>T : T, Symbol(T, Decl(functionExpressionContextualTyping.ts, 25, 8))
>U : U, Symbol(U, Decl(functionExpressionContextualTyping.ts, 25, 10))

    constructor() {
        var k: ((j: T, k: U) => (T|U)[]) | ((j: number,k :U) => number[]) = (j, k) => {
>k : ((j: T, k: U) => (T | U)[]) | ((j: number, k: U) => number[]), Symbol(k, Decl(functionExpressionContextualTyping.ts, 27, 11))
>j : T, Symbol(j, Decl(functionExpressionContextualTyping.ts, 27, 17))
>T : T, Symbol(T, Decl(functionExpressionContextualTyping.ts, 25, 8))
>k : U, Symbol(k, Decl(functionExpressionContextualTyping.ts, 27, 22))
>U : U, Symbol(U, Decl(functionExpressionContextualTyping.ts, 25, 10))
>T : T, Symbol(T, Decl(functionExpressionContextualTyping.ts, 25, 8))
>U : U, Symbol(U, Decl(functionExpressionContextualTyping.ts, 25, 10))
>j : number, Symbol(j, Decl(functionExpressionContextualTyping.ts, 27, 45))
>k : U, Symbol(k, Decl(functionExpressionContextualTyping.ts, 27, 55))
>U : U, Symbol(U, Decl(functionExpressionContextualTyping.ts, 25, 10))
>(j, k) => {            return [j, k];        } : (j: any, k: any) => any[]
>j : any, Symbol(j, Decl(functionExpressionContextualTyping.ts, 27, 77))
>k : any, Symbol(k, Decl(functionExpressionContextualTyping.ts, 27, 79))

            return [j, k];
>[j, k] : any[]
>j : any, Symbol(j, Decl(functionExpressionContextualTyping.ts, 27, 77))
>k : any, Symbol(k, Decl(functionExpressionContextualTyping.ts, 27, 79))

        }   // Per spec, no contextual signature can be extracted in this case.
    }
}
