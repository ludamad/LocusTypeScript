tests/cases/conformance/expressions/typeGuards/typeGuardFunctionErrors.ts(15,12): error TS2322: Type 'string' is not assignable to type 'boolean'.
tests/cases/conformance/expressions/typeGuards/typeGuardFunctionErrors.ts(18,55): error TS1228: Type predicates are only allowed in return type position.
tests/cases/conformance/expressions/typeGuards/typeGuardFunctionErrors.ts(22,33): error TS2304: Cannot find name 'x'.
tests/cases/conformance/expressions/typeGuards/typeGuardFunctionErrors.ts(26,10): error TS2391: Function implementation is missing or not immediately following the declaration.
tests/cases/conformance/expressions/typeGuards/typeGuardFunctionErrors.ts(27,5): error TS1131: Property or signature expected.
tests/cases/conformance/expressions/typeGuards/typeGuardFunctionErrors.ts(28,1): error TS1128: Declaration or statement expected.
tests/cases/conformance/expressions/typeGuards/typeGuardFunctionErrors.ts(30,38): error TS1225: Cannot find parameter 'x'.
tests/cases/conformance/expressions/typeGuards/typeGuardFunctionErrors.ts(34,51): error TS2322: Type 'B' is not assignable to type 'A'.
  Property 'propA' is missing in type 'B'.
tests/cases/conformance/expressions/typeGuards/typeGuardFunctionErrors.ts(38,56): error TS2322: Type 'number' is not assignable to type 'string'.
tests/cases/conformance/expressions/typeGuards/typeGuardFunctionErrors.ts(42,56): error TS2322: Type 'T[]' is not assignable to type 'string'.
tests/cases/conformance/expressions/typeGuards/typeGuardFunctionErrors.ts(56,7): error TS2339: Property 'propB' does not exist on type 'A'.
tests/cases/conformance/expressions/typeGuards/typeGuardFunctionErrors.ts(61,7): error TS2339: Property 'propB' does not exist on type 'A'.
tests/cases/conformance/expressions/typeGuards/typeGuardFunctionErrors.ts(66,7): error TS2339: Property 'propB' does not exist on type 'A'.
tests/cases/conformance/expressions/typeGuards/typeGuardFunctionErrors.ts(71,46): error TS2345: Argument of type '(p1: any) => boolean' is not assignable to parameter of type '(p1: any) => boolean'.
  Type predicate 'p1 is C' is not assignable to 'p1 is B'.
    Type 'C' is not assignable to type 'B'.
tests/cases/conformance/expressions/typeGuards/typeGuardFunctionErrors.ts(75,1): error TS2322: Type '(p1: any, p2: any) => boolean' is not assignable to type '(p1: any, p2: any) => boolean'.
  Signature '(p1: any, p2: any): boolean' must have a type predicate.
tests/cases/conformance/expressions/typeGuards/typeGuardFunctionErrors.ts(81,1): error TS2322: Type '(p1: any, p2: any) => boolean' is not assignable to type '(p1: any, p2: any) => boolean'.
  Type predicate 'p2 is A' is not assignable to 'p1 is A'.
    Parameter 'p2' is not in the same position as parameter 'p1'.
tests/cases/conformance/expressions/typeGuards/typeGuardFunctionErrors.ts(87,1): error TS2322: Type '(p1: any, p2: any, p3: any) => boolean' is not assignable to type '(p1: any, p2: any) => boolean'.
tests/cases/conformance/expressions/typeGuards/typeGuardFunctionErrors.ts(92,56): error TS1225: Cannot find parameter 'p1'.
tests/cases/conformance/expressions/typeGuards/typeGuardFunctionErrors.ts(95,9): error TS1228: Type predicates are only allowed in return type position.
tests/cases/conformance/expressions/typeGuards/typeGuardFunctionErrors.ts(96,16): error TS1228: Type predicates are only allowed in return type position.
tests/cases/conformance/expressions/typeGuards/typeGuardFunctionErrors.ts(97,20): error TS1228: Type predicates are only allowed in return type position.


==== tests/cases/conformance/expressions/typeGuards/typeGuardFunctionErrors.ts (21 errors) ====
    
    class A {
        propA: number;
    }
    
    class B {
        propB: number;
    }
    
    class C extends A {
        propC: number;
    }
    
    function hasANonBooleanReturnStatement(x): x is A {
        return '';
               ~~
!!! error TS2322: Type 'string' is not assignable to type 'boolean'.
    }
    
    function hasTypeGuardTypeInsideTypeGuardType(x): x is x is A {
                                                          ~~~~~~
!!! error TS1228: Type predicates are only allowed in return type position.
        return true;
    }
    
    function hasMissingIsKeyword(): x {
                                    ~
!!! error TS2304: Cannot find name 'x'.
        return true;
    }
    
    function hasMissingTypeInTypeGuardType(x): x is {
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2391: Function implementation is missing or not immediately following the declaration.
        return true;
        ~~~~~~
!!! error TS1131: Property or signature expected.
    }
    ~
!!! error TS1128: Declaration or statement expected.
    
    function hasNonMatchingParameter(y): x is A {
                                         ~
!!! error TS1225: Cannot find parameter 'x'.
        return true;
    }
    
    function hasNonMatchingParameterType1(x: A): x is B {
                                                      ~
!!! error TS2322: Type 'B' is not assignable to type 'A'.
!!! error TS2322:   Property 'propA' is missing in type 'B'.
        return true;
    }
    
    function hasNonMatchingParameterType2(x: string): x is number {
                                                           ~~~~~~
!!! error TS2322: Type 'number' is not assignable to type 'string'.
        return true;
    }
    
    function hasNonMathcingGenericType<T>(a: string): a is T[]Â {
                                                           ~~~
!!! error TS2322: Type 'T[]' is not assignable to type 'string'.
        return true;
    }
    
    let a: A;
    let b: B;
    
    declare function isB(p1): p1 is B;
    declare function isC(p1): p1 is C;
    declare function funA(p1: any, p2: any): p1 is B;
    declare function hasNoTypeGuard(x);
    
    // Passed argument is not the same as the one being guarded.
    if (isB(b)) {
        a.propB;
          ~~~~~
!!! error TS2339: Property 'propB' does not exist on type 'A'.
    }
    
    // Parameter index and argument index for the type guard target is not matching.
    if (funA(0, a)) {
        a.propB; // Error
          ~~~~~
!!! error TS2339: Property 'propB' does not exist on type 'A'.
    }
    
    // No type guard in if statement
    if (hasNoTypeGuard(a)) {
        a.propB; 
          ~~~~~
!!! error TS2339: Property 'propB' does not exist on type 'A'.
    }
    
    // Type predicate type is not assignable
    declare function acceptingDifferentSignatureTypeGuardFunction(p1: (p1) => p1 is B);
    acceptingDifferentSignatureTypeGuardFunction(isC);
                                                 ~~~
!!! error TS2345: Argument of type '(p1: any) => boolean' is not assignable to parameter of type '(p1: any) => boolean'.
!!! error TS2345:   Type predicate 'p1 is C' is not assignable to 'p1 is B'.
!!! error TS2345:     Type 'C' is not assignable to type 'B'.
    
    // Boolean not assignable to type guard
    var assign1: (p1, p2) => p1 is A;
    assign1 = function(p1, p2): boolean {
    ~~~~~~~
!!! error TS2322: Type '(p1: any, p2: any) => boolean' is not assignable to type '(p1: any, p2: any) => boolean'.
!!! error TS2322:   Signature '(p1: any, p2: any): boolean' must have a type predicate.
        return true;
    };
    
    // Must have matching parameter index
    var assign2: (p1, p2) => p1 is A;
    assign2 = function(p1, p2): p2 is A {
    ~~~~~~~
!!! error TS2322: Type '(p1: any, p2: any) => boolean' is not assignable to type '(p1: any, p2: any) => boolean'.
!!! error TS2322:   Type predicate 'p2 is A' is not assignable to 'p1 is A'.
!!! error TS2322:     Parameter 'p2' is not in the same position as parameter 'p1'.
        return true;
    };
    
    // No matching signature 
    var assign3: (p1, p2) => p1 is A;
    assign3 = function(p1, p2, p3): p1 is A {
    ~~~~~~~
!!! error TS2322: Type '(p1: any, p2: any, p3: any) => boolean' is not assignable to type '(p1: any, p2: any) => boolean'.
        return true;
    };
    
    // Type guard paramater referring to a binding pattern
    declare function destructureParameter({ p1, p2, p3 }): p1 is A;
                                                           ~~
!!! error TS1225: Cannot find parameter 'p1'.
    
    // Type predicates in non-return type positions
    var b1: b is A;
            ~~~~~~
!!! error TS1228: Type predicates are only allowed in return type position.
    function b2(a: b is A) {};
                   ~~~~~~
!!! error TS1228: Type predicates are only allowed in return type position.
    function b3(): A | b is A {
                       ~~~~~~
!!! error TS1228: Type predicates are only allowed in return type position.
        return true;
    };