=== tests/cases/conformance/expressions/contextualTyping/functionExpressionContextualTyping1.ts ===
// When a function expression with no type parameters and no parameter type annotations 
// is contextually typed (section 4.19) by a type T and a contextual signature S can be extracted from T

enum E { red, blue }
>E : E, Symbol(E, Decl(functionExpressionContextualTyping1.ts, 0, 0))
>red : E, Symbol(E.red, Decl(functionExpressionContextualTyping1.ts, 3, 8))
>blue : E, Symbol(E.blue, Decl(functionExpressionContextualTyping1.ts, 3, 13))

// A contextual signature S is extracted from a function type T as follows:
//      If T is a function type with exactly one call signature, and if that call signature is non- generic, S is that signature.

var a0: (n: number, s: string) => number = (num, str) => {
>a0 : (n: number, s: string) => number, Symbol(a0, Decl(functionExpressionContextualTyping1.ts, 8, 3))
>n : number, Symbol(n, Decl(functionExpressionContextualTyping1.ts, 8, 9))
>s : string, Symbol(s, Decl(functionExpressionContextualTyping1.ts, 8, 19))
>(num, str) => {    num.toExponential();    return 0;} : (num: number, str: string) => number
>num : number, Symbol(num, Decl(functionExpressionContextualTyping1.ts, 8, 44))
>str : string, Symbol(str, Decl(functionExpressionContextualTyping1.ts, 8, 48))

    num.toExponential();
>num.toExponential() : string
>num.toExponential : (fractionDigits?: number) => string, Symbol(Number.toExponential, Decl(lib.d.ts, 469, 45))
>num : number, Symbol(num, Decl(functionExpressionContextualTyping1.ts, 8, 44))
>toExponential : (fractionDigits?: number) => string, Symbol(Number.toExponential, Decl(lib.d.ts, 469, 45))

    return 0;
>0 : number
}

class Class<T> {
>Class : Class<T>, Symbol(Class, Decl(functionExpressionContextualTyping1.ts, 11, 1))
>T : T, Symbol(T, Decl(functionExpressionContextualTyping1.ts, 13, 12))

    foo() { }
>foo : () => void, Symbol(foo, Decl(functionExpressionContextualTyping1.ts, 13, 16))
}

var a1: (c: Class<Number>) => number = (a1) => {
>a1 : (c: Class<Number>) => number, Symbol(a1, Decl(functionExpressionContextualTyping1.ts, 17, 3))
>c : Class<Number>, Symbol(c, Decl(functionExpressionContextualTyping1.ts, 17, 9))
>Class : Class<T>, Symbol(Class, Decl(functionExpressionContextualTyping1.ts, 11, 1))
>Number : Number, Symbol(Number, Decl(lib.d.ts, 456, 40), Decl(lib.d.ts, 518, 11))
>(a1) => {    a1.foo();    return 1;} : (a1: Class<Number>) => number
>a1 : Class<Number>, Symbol(a1, Decl(functionExpressionContextualTyping1.ts, 17, 40))

    a1.foo();
>a1.foo() : void
>a1.foo : () => void, Symbol(Class.foo, Decl(functionExpressionContextualTyping1.ts, 13, 16))
>a1 : Class<Number>, Symbol(a1, Decl(functionExpressionContextualTyping1.ts, 17, 40))
>foo : () => void, Symbol(Class.foo, Decl(functionExpressionContextualTyping1.ts, 13, 16))

    return 1;
>1 : number
}

// A contextual signature S is extracted from a function type T as follows:
//      If T is a union type, let U be the set of element types in T that have call signatures.
//        If each type in U has exactly one call signature and that call signature is non- generic,
//        and if all of the signatures are identical ignoring return types,
//        then S is a signature with the same parameters and a union of the return types.
var b1: ((s: string, w: boolean) => void) | ((s: string, w: boolean) => string);
>b1 : ((s: string, w: boolean) => void) | ((s: string, w: boolean) => string), Symbol(b1, Decl(functionExpressionContextualTyping1.ts, 27, 3))
>s : string, Symbol(s, Decl(functionExpressionContextualTyping1.ts, 27, 10))
>w : boolean, Symbol(w, Decl(functionExpressionContextualTyping1.ts, 27, 20))
>s : string, Symbol(s, Decl(functionExpressionContextualTyping1.ts, 27, 46))
>w : boolean, Symbol(w, Decl(functionExpressionContextualTyping1.ts, 27, 56))

b1 = (k, h) => { };
>b1 = (k, h) => { } : (k: string, h: boolean) => void
>b1 : ((s: string, w: boolean) => void) | ((s: string, w: boolean) => string), Symbol(b1, Decl(functionExpressionContextualTyping1.ts, 27, 3))
>(k, h) => { } : (k: string, h: boolean) => void
>k : string, Symbol(k, Decl(functionExpressionContextualTyping1.ts, 28, 6))
>h : boolean, Symbol(h, Decl(functionExpressionContextualTyping1.ts, 28, 8))

var b2: typeof a0 | ((n: number, s: string) => string);
>b2 : ((n: number, s: string) => number) | ((n: number, s: string) => string), Symbol(b2, Decl(functionExpressionContextualTyping1.ts, 29, 3))
>a0 : (n: number, s: string) => number, Symbol(a0, Decl(functionExpressionContextualTyping1.ts, 8, 3))
>n : number, Symbol(n, Decl(functionExpressionContextualTyping1.ts, 29, 22))
>s : string, Symbol(s, Decl(functionExpressionContextualTyping1.ts, 29, 32))

b2 = (foo, bar) => { return foo + 1; }
>b2 = (foo, bar) => { return foo + 1; } : (foo: number, bar: string) => number
>b2 : ((n: number, s: string) => number) | ((n: number, s: string) => string), Symbol(b2, Decl(functionExpressionContextualTyping1.ts, 29, 3))
>(foo, bar) => { return foo + 1; } : (foo: number, bar: string) => number
>foo : number, Symbol(foo, Decl(functionExpressionContextualTyping1.ts, 30, 6))
>bar : string, Symbol(bar, Decl(functionExpressionContextualTyping1.ts, 30, 10))
>foo + 1 : number
>foo : number, Symbol(foo, Decl(functionExpressionContextualTyping1.ts, 30, 6))
>1 : number

b2 = (foo, bar) => { return "hello"; }
>b2 = (foo, bar) => { return "hello"; } : (foo: number, bar: string) => string
>b2 : ((n: number, s: string) => number) | ((n: number, s: string) => string), Symbol(b2, Decl(functionExpressionContextualTyping1.ts, 29, 3))
>(foo, bar) => { return "hello"; } : (foo: number, bar: string) => string
>foo : number, Symbol(foo, Decl(functionExpressionContextualTyping1.ts, 31, 6))
>bar : string, Symbol(bar, Decl(functionExpressionContextualTyping1.ts, 31, 10))
>"hello" : string

var b3: (name: string, num: number, boo: boolean) => void;
>b3 : (name: string, num: number, boo: boolean) => void, Symbol(b3, Decl(functionExpressionContextualTyping1.ts, 32, 3))
>name : string, Symbol(name, Decl(functionExpressionContextualTyping1.ts, 32, 9))
>num : number, Symbol(num, Decl(functionExpressionContextualTyping1.ts, 32, 22))
>boo : boolean, Symbol(boo, Decl(functionExpressionContextualTyping1.ts, 32, 35))

b3 = (name, number) => { };
>b3 = (name, number) => { } : (name: string, number: number) => void
>b3 : (name: string, num: number, boo: boolean) => void, Symbol(b3, Decl(functionExpressionContextualTyping1.ts, 32, 3))
>(name, number) => { } : (name: string, number: number) => void
>name : string, Symbol(name, Decl(functionExpressionContextualTyping1.ts, 33, 6))
>number : number, Symbol(number, Decl(functionExpressionContextualTyping1.ts, 33, 11))

var b4: (n: E) => string = (number = 1) => { return "hello"; };
>b4 : (n: E) => string, Symbol(b4, Decl(functionExpressionContextualTyping1.ts, 35, 3))
>n : E, Symbol(n, Decl(functionExpressionContextualTyping1.ts, 35, 9))
>E : E, Symbol(E, Decl(functionExpressionContextualTyping1.ts, 0, 0))
>(number = 1) => { return "hello"; } : (number?: E) => string
>number : E, Symbol(number, Decl(functionExpressionContextualTyping1.ts, 35, 28))
>1 : number
>"hello" : string

var b5: (n: {}) => string = (number = "string") => { return "hello"; };
>b5 : (n: {}) => string, Symbol(b5, Decl(functionExpressionContextualTyping1.ts, 36, 3))
>n : {}, Symbol(n, Decl(functionExpressionContextualTyping1.ts, 36, 9))
>(number = "string") => { return "hello"; } : (number?: {}) => string
>number : {}, Symbol(number, Decl(functionExpressionContextualTyping1.ts, 36, 29))
>"string" : string
>"hello" : string

// A contextual signature S is extracted from a function type T as follows:
//      Otherwise, no contextual signature can be extracted from T and S is undefined.
var b6: ((s: string, w: boolean) => void) | ((n: number) => number);
>b6 : ((s: string, w: boolean) => void) | ((n: number) => number), Symbol(b6, Decl(functionExpressionContextualTyping1.ts, 40, 3))
>s : string, Symbol(s, Decl(functionExpressionContextualTyping1.ts, 40, 10))
>w : boolean, Symbol(w, Decl(functionExpressionContextualTyping1.ts, 40, 20))
>n : number, Symbol(n, Decl(functionExpressionContextualTyping1.ts, 40, 46))

var b7: ((s: string, w: boolean) => void) | ((s: string, w: number) => string);
>b7 : ((s: string, w: boolean) => void) | ((s: string, w: number) => string), Symbol(b7, Decl(functionExpressionContextualTyping1.ts, 41, 3))
>s : string, Symbol(s, Decl(functionExpressionContextualTyping1.ts, 41, 10))
>w : boolean, Symbol(w, Decl(functionExpressionContextualTyping1.ts, 41, 20))
>s : string, Symbol(s, Decl(functionExpressionContextualTyping1.ts, 41, 46))
>w : number, Symbol(w, Decl(functionExpressionContextualTyping1.ts, 41, 56))

b6 = (k) => { k.toLowerCase() };
>b6 = (k) => { k.toLowerCase() } : (k: any) => void
>b6 : ((s: string, w: boolean) => void) | ((n: number) => number), Symbol(b6, Decl(functionExpressionContextualTyping1.ts, 40, 3))
>(k) => { k.toLowerCase() } : (k: any) => void
>k : any, Symbol(k, Decl(functionExpressionContextualTyping1.ts, 42, 6))
>k.toLowerCase() : any
>k.toLowerCase : any
>k : any, Symbol(k, Decl(functionExpressionContextualTyping1.ts, 42, 6))
>toLowerCase : any

b6 = (i) => {
>b6 = (i) => {    i.toExponential();    return i;} : (i: any) => any
>b6 : ((s: string, w: boolean) => void) | ((n: number) => number), Symbol(b6, Decl(functionExpressionContextualTyping1.ts, 40, 3))
>(i) => {    i.toExponential();    return i;} : (i: any) => any
>i : any, Symbol(i, Decl(functionExpressionContextualTyping1.ts, 43, 6))

    i.toExponential();
>i.toExponential() : any
>i.toExponential : any
>i : any, Symbol(i, Decl(functionExpressionContextualTyping1.ts, 43, 6))
>toExponential : any

    return i;
>i : any, Symbol(i, Decl(functionExpressionContextualTyping1.ts, 43, 6))

};                   // Per spec, no contextual signature can be extracted in this case. (Otherwise clause)
b7 = (j, m) => { };  // Per spec, no contextual signature can be extracted in this case. (Otherwise clause)
>b7 = (j, m) => { } : (j: any, m: any) => void
>b7 : ((s: string, w: boolean) => void) | ((s: string, w: number) => string), Symbol(b7, Decl(functionExpressionContextualTyping1.ts, 41, 3))
>(j, m) => { } : (j: any, m: any) => void
>j : any, Symbol(j, Decl(functionExpressionContextualTyping1.ts, 47, 6))
>m : any, Symbol(m, Decl(functionExpressionContextualTyping1.ts, 47, 8))

class C<T, U> {
>C : C<T, U>, Symbol(C, Decl(functionExpressionContextualTyping1.ts, 47, 19))
>T : T, Symbol(T, Decl(functionExpressionContextualTyping1.ts, 49, 8))
>U : U, Symbol(U, Decl(functionExpressionContextualTyping1.ts, 49, 10))

    constructor() {
        var k: ((j: T, k: U) => (T|U)[]) | ((j: number,k :U) => number[]) = (j, k) => {
>k : ((j: T, k: U) => (T | U)[]) | ((j: number, k: U) => number[]), Symbol(k, Decl(functionExpressionContextualTyping1.ts, 51, 11))
>j : T, Symbol(j, Decl(functionExpressionContextualTyping1.ts, 51, 17))
>T : T, Symbol(T, Decl(functionExpressionContextualTyping1.ts, 49, 8))
>k : U, Symbol(k, Decl(functionExpressionContextualTyping1.ts, 51, 22))
>U : U, Symbol(U, Decl(functionExpressionContextualTyping1.ts, 49, 10))
>T : T, Symbol(T, Decl(functionExpressionContextualTyping1.ts, 49, 8))
>U : U, Symbol(U, Decl(functionExpressionContextualTyping1.ts, 49, 10))
>j : number, Symbol(j, Decl(functionExpressionContextualTyping1.ts, 51, 45))
>k : U, Symbol(k, Decl(functionExpressionContextualTyping1.ts, 51, 55))
>U : U, Symbol(U, Decl(functionExpressionContextualTyping1.ts, 49, 10))
>(j, k) => {            return [j, k];        } : (j: any, k: any) => any[]
>j : any, Symbol(j, Decl(functionExpressionContextualTyping1.ts, 51, 77))
>k : any, Symbol(k, Decl(functionExpressionContextualTyping1.ts, 51, 79))

            return [j, k];
>[j, k] : any[]
>j : any, Symbol(j, Decl(functionExpressionContextualTyping1.ts, 51, 77))
>k : any, Symbol(k, Decl(functionExpressionContextualTyping1.ts, 51, 79))

        }   // Per spec, no contextual signature can be extracted in this case.
    }
}
