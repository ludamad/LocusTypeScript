=== tests/cases/conformance/types/tuple/typeInferenceWithTupleType.ts ===
function combine<T, U>(x: T, y: U): [T, U] {
>combine : <T, U>(x: T, y: U) => [T, U], Symbol(combine, Decl(typeInferenceWithTupleType.ts, 0, 0))
>T : T, Symbol(T, Decl(typeInferenceWithTupleType.ts, 0, 17))
>U : U, Symbol(U, Decl(typeInferenceWithTupleType.ts, 0, 19))
>x : T, Symbol(x, Decl(typeInferenceWithTupleType.ts, 0, 23))
>T : T, Symbol(T, Decl(typeInferenceWithTupleType.ts, 0, 17))
>y : U, Symbol(y, Decl(typeInferenceWithTupleType.ts, 0, 28))
>U : U, Symbol(U, Decl(typeInferenceWithTupleType.ts, 0, 19))
>T : T, Symbol(T, Decl(typeInferenceWithTupleType.ts, 0, 17))
>U : U, Symbol(U, Decl(typeInferenceWithTupleType.ts, 0, 19))

    return [x, y];
>[x, y] : [T, U]
>x : T, Symbol(x, Decl(typeInferenceWithTupleType.ts, 0, 23))
>y : U, Symbol(y, Decl(typeInferenceWithTupleType.ts, 0, 28))
}

var combineResult = combine("string", 10);
>combineResult : [string, number], Symbol(combineResult, Decl(typeInferenceWithTupleType.ts, 4, 3))
>combine("string", 10) : [string, number]
>combine : <T, U>(x: T, y: U) => [T, U], Symbol(combine, Decl(typeInferenceWithTupleType.ts, 0, 0))
>"string" : string
>10 : number

var combineEle1 = combineResult[0]; // string
>combineEle1 : string, Symbol(combineEle1, Decl(typeInferenceWithTupleType.ts, 5, 3))
>combineResult[0] : string
>combineResult : [string, number], Symbol(combineResult, Decl(typeInferenceWithTupleType.ts, 4, 3))
>0 : number, Symbol(0)

var combineEle2 = combineResult[1]; // number
>combineEle2 : number, Symbol(combineEle2, Decl(typeInferenceWithTupleType.ts, 6, 3))
>combineResult[1] : number
>combineResult : [string, number], Symbol(combineResult, Decl(typeInferenceWithTupleType.ts, 4, 3))
>1 : number, Symbol(1)

function zip<T, U>(array1: T[], array2: U[]): [[T, U]] {
>zip : <T, U>(array1: T[], array2: U[]) => [[T, U]], Symbol(zip, Decl(typeInferenceWithTupleType.ts, 6, 35))
>T : T, Symbol(T, Decl(typeInferenceWithTupleType.ts, 8, 13))
>U : U, Symbol(U, Decl(typeInferenceWithTupleType.ts, 8, 15))
>array1 : T[], Symbol(array1, Decl(typeInferenceWithTupleType.ts, 8, 19))
>T : T, Symbol(T, Decl(typeInferenceWithTupleType.ts, 8, 13))
>array2 : U[], Symbol(array2, Decl(typeInferenceWithTupleType.ts, 8, 31))
>U : U, Symbol(U, Decl(typeInferenceWithTupleType.ts, 8, 15))
>T : T, Symbol(T, Decl(typeInferenceWithTupleType.ts, 8, 13))
>U : U, Symbol(U, Decl(typeInferenceWithTupleType.ts, 8, 15))

    if (array1.length != array2.length) {
>array1.length != array2.length : boolean
>array1.length : number, Symbol(Array.length, Decl(lib.d.ts, 1007, 20))
>array1 : T[], Symbol(array1, Decl(typeInferenceWithTupleType.ts, 8, 19))
>length : number, Symbol(Array.length, Decl(lib.d.ts, 1007, 20))
>array2.length : number, Symbol(Array.length, Decl(lib.d.ts, 1007, 20))
>array2 : U[], Symbol(array2, Decl(typeInferenceWithTupleType.ts, 8, 31))
>length : number, Symbol(Array.length, Decl(lib.d.ts, 1007, 20))

        return [[undefined, undefined]];
>[[undefined, undefined]] : [[undefined, undefined]]
>[undefined, undefined] : [undefined, undefined]
>undefined : undefined, Symbol(undefined)
>undefined : undefined, Symbol(undefined)
    }
    var length = array1.length;
>length : number, Symbol(length, Decl(typeInferenceWithTupleType.ts, 12, 7))
>array1.length : number, Symbol(Array.length, Decl(lib.d.ts, 1007, 20))
>array1 : T[], Symbol(array1, Decl(typeInferenceWithTupleType.ts, 8, 19))
>length : number, Symbol(Array.length, Decl(lib.d.ts, 1007, 20))

    var zipResult: [[T, U]];
>zipResult : [[T, U]], Symbol(zipResult, Decl(typeInferenceWithTupleType.ts, 13, 7))
>T : T, Symbol(T, Decl(typeInferenceWithTupleType.ts, 8, 13))
>U : U, Symbol(U, Decl(typeInferenceWithTupleType.ts, 8, 15))

    for (var i = 0; i < length; ++i) {
>i : number, Symbol(i, Decl(typeInferenceWithTupleType.ts, 14, 12))
>0 : number
>i < length : boolean
>i : number, Symbol(i, Decl(typeInferenceWithTupleType.ts, 14, 12))
>length : number, Symbol(length, Decl(typeInferenceWithTupleType.ts, 12, 7))
>++i : number
>i : number, Symbol(i, Decl(typeInferenceWithTupleType.ts, 14, 12))

        zipResult.push([array1[i], array2[i]]);
>zipResult.push([array1[i], array2[i]]) : number
>zipResult.push : (...items: [T, U][]) => number, Symbol(Array.push, Decl(lib.d.ts, 1016, 29))
>zipResult : [[T, U]], Symbol(zipResult, Decl(typeInferenceWithTupleType.ts, 13, 7))
>push : (...items: [T, U][]) => number, Symbol(Array.push, Decl(lib.d.ts, 1016, 29))
>[array1[i], array2[i]] : [T, U]
>array1[i] : T
>array1 : T[], Symbol(array1, Decl(typeInferenceWithTupleType.ts, 8, 19))
>i : number, Symbol(i, Decl(typeInferenceWithTupleType.ts, 14, 12))
>array2[i] : U
>array2 : U[], Symbol(array2, Decl(typeInferenceWithTupleType.ts, 8, 31))
>i : number, Symbol(i, Decl(typeInferenceWithTupleType.ts, 14, 12))
    }
    return zipResult;
>zipResult : [[T, U]], Symbol(zipResult, Decl(typeInferenceWithTupleType.ts, 13, 7))
}

var zipResult = zip(["foo", "bar"], [5, 6]);
>zipResult : [[string, number]], Symbol(zipResult, Decl(typeInferenceWithTupleType.ts, 20, 3))
>zip(["foo", "bar"], [5, 6]) : [[string, number]]
>zip : <T, U>(array1: T[], array2: U[]) => [[T, U]], Symbol(zip, Decl(typeInferenceWithTupleType.ts, 6, 35))
>["foo", "bar"] : string[]
>"foo" : string
>"bar" : string
>[5, 6] : number[]
>5 : number
>6 : number

var zipResultEle = zipResult[0]; // [string, number]
>zipResultEle : [string, number], Symbol(zipResultEle, Decl(typeInferenceWithTupleType.ts, 21, 3))
>zipResult[0] : [string, number]
>zipResult : [[string, number]], Symbol(zipResult, Decl(typeInferenceWithTupleType.ts, 20, 3))
>0 : number, Symbol(0)

var zipResultEleEle = zipResult[0][0]; // string
>zipResultEleEle : string, Symbol(zipResultEleEle, Decl(typeInferenceWithTupleType.ts, 22, 3))
>zipResult[0][0] : string
>zipResult[0] : [string, number]
>zipResult : [[string, number]], Symbol(zipResult, Decl(typeInferenceWithTupleType.ts, 20, 3))
>0 : number, Symbol(0)
>0 : number, Symbol(0)


