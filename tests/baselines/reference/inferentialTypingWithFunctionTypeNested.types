=== tests/cases/compiler/inferentialTypingWithFunctionTypeNested.ts ===
declare function map<T, U>(x: T, f: () => { x: (s: T) => U }): U;
>map : <T, U>(x: T, f: () => { x: (s: T) => U; }) => U, Symbol(map, Decl(inferentialTypingWithFunctionTypeNested.ts, 0, 0))
>T : T, Symbol(T, Decl(inferentialTypingWithFunctionTypeNested.ts, 0, 21))
>U : U, Symbol(U, Decl(inferentialTypingWithFunctionTypeNested.ts, 0, 23))
>x : T, Symbol(x, Decl(inferentialTypingWithFunctionTypeNested.ts, 0, 27))
>T : T, Symbol(T, Decl(inferentialTypingWithFunctionTypeNested.ts, 0, 21))
>f : () => { x: (s: T) => U; }, Symbol(f, Decl(inferentialTypingWithFunctionTypeNested.ts, 0, 32))
>x : (s: T) => U, Symbol(x, Decl(inferentialTypingWithFunctionTypeNested.ts, 0, 43))
>s : T, Symbol(s, Decl(inferentialTypingWithFunctionTypeNested.ts, 0, 48))
>T : T, Symbol(T, Decl(inferentialTypingWithFunctionTypeNested.ts, 0, 21))
>U : U, Symbol(U, Decl(inferentialTypingWithFunctionTypeNested.ts, 0, 23))
>U : U, Symbol(U, Decl(inferentialTypingWithFunctionTypeNested.ts, 0, 23))

declare function identity<V>(y: V): V;
>identity : <V>(y: V) => V, Symbol(identity, Decl(inferentialTypingWithFunctionTypeNested.ts, 0, 65))
>V : V, Symbol(V, Decl(inferentialTypingWithFunctionTypeNested.ts, 1, 26))
>y : V, Symbol(y, Decl(inferentialTypingWithFunctionTypeNested.ts, 1, 29))
>V : V, Symbol(V, Decl(inferentialTypingWithFunctionTypeNested.ts, 1, 26))
>V : V, Symbol(V, Decl(inferentialTypingWithFunctionTypeNested.ts, 1, 26))

var s = map("", () => { return { x: identity }; });
>s : string, Symbol(s, Decl(inferentialTypingWithFunctionTypeNested.ts, 3, 3))
>map("", () => { return { x: identity }; }) : string
>map : <T, U>(x: T, f: () => { x: (s: T) => U; }) => U, Symbol(map, Decl(inferentialTypingWithFunctionTypeNested.ts, 0, 0))
>"" : string
>() => { return { x: identity }; } : () => { x: (y: string) => string; }
>{ x: identity } : { x: <V>(y: V) => V; }
>x : <V>(y: V) => V, Symbol(x, Decl(inferentialTypingWithFunctionTypeNested.ts, 3, 32))
>identity : <V>(y: V) => V, Symbol(identity, Decl(inferentialTypingWithFunctionTypeNested.ts, 0, 65))

